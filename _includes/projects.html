<section class="section projects-section">
    <h2 class="section-title"><i class="fa fa-archive"></i>项目经历</h2>
    <!--//手机版刷机精灵的重构及维护-->
    <div class="item">
        <div class="meta">
            <div class="upper-row">
                <h3 class="project-title">1. 手机版刷机精灵的重构及维护</h3>
                <div class="time">2015.11 - 现在</div>
            </div>
            <!--//upper-row-->
        </div>
        <!--//meta-->
        <div class="intro">
            <p>手机版刷机精灵是公司的核心产品，有以刷机功能为核心的一系列功能，比如:ROM下载，Root，资料备份及恢复，系统优化，安全加固，耗电管理，手机降温，应用市场，卸载预装，自启管理，应用升级，百宝箱，推荐信息流。众多复杂的功能给技术架构带来很大的挑战</p>
        </div>
        <div class="tech">
            <h3>技术要点:</h3>
            <ol>
                <li>模块化的架构设计 以功能为单位划分模块，每个功能模块都在一个单独的模块工程里，只选择需要的模块即可快速开发出一个新的产品。每个模块还可以为不同的产品定制不同的逻辑，资源，配置以实现定制。通过这种架构设计，每个产品都只包含它需要的模块，逻辑，配置，资源，可以让每个产品的体积尽量小。另外，每个模块只需维护一套供各产品共用的逻辑，具有更低的维护成本。所有产品共用一个公共基础模块，在公共基础模块里设计了一个模块管理器，产品用到的模块对象都会在模块管理器里注册，每个模块都可通过模块管理器取得其它模块，然后调用其它模块的功能</li>
                <li>提取通用组件，放在局域网的组件仓库，供所有产品使用。每个组件都有版本管理，如果需要使用通用组件，只需在build.gradle里添加依赖即可使用该组件，如果组件依赖了其它组件，也会自动下载依赖的特定版本的组件。通过这种方式解决了以前通用代码散布在各个产品带来的可维护性非常差的问题。另外因为这些组件通常都是aar包，解决了以前使用第三方组件时还需拷贝动态库，资源文件，设置AndroidManifest等多种麻烦问题</li>
                <li>多进程的架构设计 将内存消耗比较大的逻辑放在非主进程，解决主进程因内存回收带来的卡顿问题，将常驻逻辑放在常驻进程，和主进程隔离，解决主进程经常被系统杀掉的问题，还可以通过多进程解决引入外部库导致的主进程卡死问题</li>
                <li>模块内部设计采用MVC，隔离业务逻辑和界面逻辑，应用启动时会初始化每个模块的业务逻辑层， 提前缓存该模块的数据，当用户进入该功能模块时因为数据已经准备好，所以可以无缝使用该功能</li>
                <li>通过并行初始化，延迟非关键组件的初始化等手段保证应用启动速度</li>
                <li>Task-Based的多线程设计，将任务进行分类，不同的任务放到到不同类型的线程池里运行，保证任务的高效执行以及多线程逻辑的可调试性，因为在调试器里可以知道执行的任务所在的线程，可以分析线程当前的状态得到当前任务执行的状态，也能明确是否产生死锁</li>
                <li>支持抢断的优化任务调度器，可以高效响应用户的优化操作，解决优化任务非常耗时还不能打断的问题。清理扫描时，用户进入安全扫描后，会立即启动安全扫描，安全扫描后又会继续先前未完成的清理扫描。此种情况下还能保证全局的扫描进度是累加的，而不是从头开始。</li>
            </ol>
        </div>
        <div class="responsibility">
            <h3>项目职责:</h3>
            <p>搭建框架，实现核心模块的业务逻辑，解决疑难问题，代码Review，任务分配</p>
        </div>
    </div>
    <!--//精灵助手重构-->
    <div class="item">
        <div class="meta">
            <div class="upper-row">
                <h3 class="project-title">2. 精灵助手重构</h3>
                <div class="time">2015.8 - 2015.9</div>
            </div>
            <!--//upper-row-->
        </div>
        <!--//meta-->
        <div class="intro">
            <p>精灵助手是 PC 端刷机精灵的辅助应用，协助 PC 端刷机精灵完成手机信息的获 取，并实现联系人，短信，通话记录，wifi，图片，应用数据等资料的备份和还原</p>
            <p>重构时实现了 Jar 包形式的精灵助手，在有 Root 权限的情况下，可以绕过第三 方授权管理组件备份还原用户资料(通话记录，短信，联系人)。Apk 形式的精灵 助手也做了比较大的架构调整，解决了先前通讯，线程管理混乱的问题，提高了 备份，还原的成功率</p>
        </div>
        <div class="tech">
            <h3>技术要点:</h3>
            <ol>
                <li>实现Jar包形式的精灵助手参考了content命令的实现，通过ActvityManager调用getContentProviderExternal函数可得到ContentProviderHolder，然后通过该对象指定要操作的uri即可查询联系人，短信，通话记录等资</li>
                <li>Task-Based的多线程设计以前PC端每发送一个命令过来，都会创建一个新的线程，执行该命令，这样可能造成多个线程的同步问题，比如出现两个线程同时还原资料，造成资料重复。另外因为多线程的原因，增加了分析问题的复杂性。现在采用了Task-based的多线程设计，将所有PC端的命令分成了4种类型，SIMPLE类型的命令放在单线程的线程池里执行，PIM类型的命令放在另一个单线程的线程池里执行，并且有看门狗线程负责观察命令是否执行超时，FILE类型的命令放在固定数目线程的线程池里执行，MEDIA_TIME类型的命令放在cache类的线程池里执行。如果某个命令执行出问题，可以在调试窗口迅速找到执行命令的线程，然后查看线程执行的状态，相比Actor-based的多线程设计，有更好的可分析性</li>
                <li>我们在和PC端通信时，最初设计便采用了NIO的通信方式，但是虽然采用了该方式，我们还是设计了3个线程用于管理和PC端的通信，一个监听PC端请求的线程，一个读取PC端发送过来的数据的线程，一个发送数据至PC端的线程，这样的设计非常复杂，不便于分析。重构后，我们取消了读取数据和发送数据的线程，只保留了一个监听PC客户端请求的线程，在该线程里检测到PC端发送数据过来后，就调用ClientSession的receiveData接收数据，如果执行的命令准备好发送给PC端的数据了，则通过SelectKey的interestOps将该通道设置有数据需要发送，则在服务线程里即可知道，然后在服务线程里将数据真正地发送给PC端</li>
            </ol>
        </div>
        <div class="responsibility">
            <h3>项目职责:</h3>
            <p>搭建框架，实现核心的业务逻辑(任务调度，和PC端通信的逻辑，命令执行框架，部分命令逻辑)，任务分配 </p>
        </div>
    </div>
</section>
